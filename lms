#!/usr/bin/env lua

-- Start with some local convenience functions

tConcat = table.concat
tInsert = table.insert
tRemove = table.remove
tSort   = table.sort
getEnv  = os.getenv
lfs     = require 'lfs'

-- Now update the require search paths to ensure lms standard paths will 
-- be searched 

directorySeparator = package.config:sub(1,1)

function makePath(pathTable)
  return tConcat(pathTable, directorySeparator)
end

package.path = tConcat({
  makePath{'.', '?'},
  makePath{'.', 'lib', '?'},
  makePath{'.', 'lib', '?.lua'},
  makePath{getEnv('HOME'), '.luaMakeSystem', '?'},
  makePath{getEnv('HOME'), '.luaMakeSystem','?.lua'},
  package.path
},';')

package.cpath = tConcat({
  makePath{'.', 'luaLibs', '?.so'},
  makePath{getEnv('HOME'), '.luaMakeSystem', '?.so'},
  package.cpath
}, ';')

-- Now load any user's local lms configuration

-- The following conditional require is adapted from: shuva's answer to 
--  "How to check if a module exists in Lua?"
-- see: http://stackoverflow.com/a/22686090

local hasLmsConfig, lmsConfig = pcall(require, "lmsConfig")
if not hasLmsConfig then lmsConfig = { } end
lms = lmsConfig

-- Now define some functions to help communicate with the user 

clearScreen = lms.clearScreen or true
verbose     = lms.verbose     or false
veryVerbose = lms.veryVerbose or false

function lmsError(aMessage)
  print('ERROR: '..aMessage)
  os.exit(-1)
end

function lmsMessage(...)
  if verbose then
    print('---------------------------------------')
    for i, aMessage in ipairs({...}) do
      print(aMessage)
    end
  end
end

function lmsMessageCont(...)
  if verbose then
    for i, aMessage in ipairs({...}) do
      print(aMessage)
    end
  end
end

function lmsMessageVery(...)
  if veryVerbose then
    for i, aMessage in ipairs({...}) do
      print(aMessage)
    end
  end
end

-- Now compute the OS (which can be used to require different versions of 
-- the lms modules) 

function getOutputFromCmd(aCmd)
  lmsMessageVery('getting output from: ['..aCmd..']')
  local proc = io.popen(aCmd..' 2>&1', 'r')
  if not proc then return '' end
  local result = proc:read('*a')
  proc:close()
  local result = result:gsub('\n$','')
  return result
end

if package.config:sub(1,1) == '\\' then
  lms.os = 'Windows'
else
  lms.os = getOutputFromCmd('uname -s')
end

-- Now create a collection of global functions to act as a DSL 

targets    = {}
targetList = {}
alreadyRun = {}

function runCmdIn(cmd, subDir)
  local curDir = lfs.currentdir()
  print('\n========================================================')
  print('working in ['..subDir..']')
  print('running    ['..cmd..']')
  lfs.chdir(subDir)
  if not os.execute(cmd) then
    print('FAILED to run: ['..cmd..']')
    os.exit(-1)
  end
  lfs.chdir(curDir)
end

function executeCmd(aCmd)
  lmsMessage('running: ['..aCmd..']')
  return os.execute(aCmd)
end

function chDir(aNewDir)
  if not lfs.chdir(aNewDir) then 
    lmsError('could not change directory to: ['..aNewDir..']')
  end
end

function target(tDef)
  if 0 < #tDef then tDef.target       = tRemove(tDef, 1) end
  if 0 < #tDef then tDef.dependencies = tRemove(tDef, 1) end
  if 0 < #tDef then tDef.command      = tRemove(tDef, 1) end
  if not tDef.target then 
    lmsError(debug.traceback('target method did not supply a target')) 
  end
  if not targets[tDef.target] then -- first definition wins!
    targets[tDef.target] = tDef
    tInsert(targetList, tDef.target)
  end
  return tDef.target
end

function needsToBuild(aTargetDef)
  tTime = lfs.attributes(aTargetDef.target, 'modification')
  if (tTime) then
    lmsMessageCont('  ('..os.date('%Y/%m/%d %H:%M:%S', tTime)..')['..tTime..']')
  else
    lmsMessageCont('  (does not exist)')
  end
  if not tTime then 
    lmsMessage('need to build ['..aTargetDef.target..']\nsince target does not exist')
    return true
  end
  
  for i, aDependency in ipairs(aTargetDef.dependencies) do
    if lfs.attributes(aDependency, 'mode') ~= 'directory' then
      dTime = lfs.attributes(aDependency, 'modification')
      if not dTime then lmsError('missing dependency: ['..aDependency..']') end
      if dTime > tTime then
        lmsMessage(
          'need to build ['..aTargetDef.target..']',
          'since ['..aDependency..']',
          'is newer ('..os.date('%Y/%m/%d %H:%M:%S', dTime)..')['..dTime..']',
          'than the target ('..os.date('%Y/%m/%d %H:%M:%S', tTime)..')['..tTime..']'
          )
        return true
      end
    end
  end
  lmsMessageVery('all dependencies older than target')
  return false
end

local toStr   = tostring

local function compareKeyValues(a, b)
  return (a[1] < b[1])
end

function prettyPrint(anObj, indent)
  local result = ""
  indent = indent or ""
  if type(anObj) == 'nil' then
    result = 'nil'
  elseif type(anObj) == 'boolean' then
    if anObj then result = 'true' else result = 'false' end
  elseif type(anObj) == 'number' then
    result = toStr(anObj)
  elseif type(anObj) == 'string' then
    result = '"'..anObj..'"'
  elseif type(anObj) == 'function' then
    result = toStr(anObj)
  elseif type(anObj) == 'userdata' then
    result = toStr(anObj)
  elseif type(anObj) == 'thread' then
    result = toStr(anObj)
  elseif type(anObj) == 'table' then
    local origIndent = indent
    indent = indent..'  '
    result = '{\n'
    for i, aValue in ipairs(anObj) do
      result = result..indent..prettyPrint(aValue, indent)..',\n'
    end
    local theKeyValues = { }
    for aKey, aValue in pairs(anObj) do
      if type(aKey) ~= 'number' or aKey < 1 or #anObj < aKey then
        tInsert(theKeyValues,
          { prettyPrint(aKey), aKey, prettyPrint(aValue, indent) })
      end
    end
    tSort(theKeyValues, compareKeyValues)
    for i, aKeyValue in ipairs(theKeyValues) do
      result = result..indent..'['..aKeyValue[1]..'] = '..aKeyValue[3]..',\n'
    end
    result = result..origIndent..'}'
  else
    result = 'UNKNOWN TYPE: ['..toStr(anObj)..']'
  end
  return result
end

function showTarget(targetToRun)
  print("=======================================")
  print("The target for: ["..targetToRun.."]")
  print(prettyPrint(targets[targetToRun]))
  print("=======================================")
end

function mustHaveTarget(targetToRun)
  local aTarget = targets[targetToRun]
  if not aTarget then
    lmsError(' no target found for ['..targetToRun..']')
  end
end

function runTarget(targetToRun)
  if alreadyRun[targetToRun] then
    lmsMessageVery('already run '..targetToRun)
    return
  end
  
  lmsMessage('checking: '..targetToRun)
  
  local aTarget = targets[targetToRun]
  if not aTarget then
    lmsMessageVery('nothing to do')
    return
  end  

  if aTarget.dependencies then
    for i, aDependency in ipairs(aTarget.dependencies) do
      runTarget(aDependency)
    end
  else
    lmsMessageCont('no dependencies key found')
  end

  lmsMessage('(re)checking: '..targetToRun)
  if aTarget.command then
    lmsMessageCont('  has command')
  else
    lmsMessageCont('  has NO command')
  end
  
  if aTarget.command and needsToBuild(aTarget) then
    if type(aTarget.command) == 'string' then
      lmsMessageCont(
       'building ['..aTarget.target..']\nusing ['..aTarget.command..']'
      )
      if not os.execute(aTarget.command) then
        lmsError('could not run ['..aTarget.command..']')
      end
    elseif type(aTarget.command) == 'function' then
      lmsMessageCont('building ['..aTarget.target..']')
      if not aTarget.command(aTarget) then
        lmsError('could not run command for ['..aTarget.target..']')
      end
    else
      lmsError('the command for target ['..aTarget.target..'] MUSt be either a string or a function.')
    end
  end
  alreadyRun[targetToRun] = true
end

-- Now we create some general helper tools

function getParentPath(aPath)
  local parentPath =
    aPath:gsub(directorySeparator..'?[^'..directorySeparator..']*$', '')
--  print('getParentPath: ['..aPath..']->['..parentPath..']')
  if #parentPath < 1 then parentPath = nil end
  return parentPath
end

local function createPath(aTarget)
  return lfs.mkdir(aTarget.target)
end

function ensurePathExists(aPath)
  if not aPath then return '' end
  local paths = { }
  local parentPath = getParentPath(aPath)
  if parentPath then
    ensurePathExists(parentPath)
    paths = { parentPath }
  end
  return target({
    dependencies = paths,
    target       = aPath,
    command      = createPath
  })
end

-- Now we create a helper tools to be able to deal with options 

lmsOptionHelp     = { }
lmsLongSwitches   = { }
lmsOption         = { }
runDefault        = true
shouldListTargets = false

function addOption( shortSwitch, longSwitch, description, action)
  lmsOptionHelp[longSwitch] = { shortSwitch, longSwitch, description, action }
  tInsert(lmsLongSwitches, longSwitch)
  lmsOption[shortSwitch] = action
  lmsOption[longSwitch]  = action
end

addOption('-h', '--help', 'Provide this list of options', function()
  runDefault = false
  print('lms -- Lua Make System\n')
  print('usage: lms [options] [targets]\n')
  print('where: targets is a space delimited list of lms targets to be run,')
  print('and options is one of the following:\n')
  tSort(lmsLongSwitches)
  local longestSwitch = 0
  for i, aSwitch in ipairs(lmsLongSwitches) do
    if longestSwitch < #aSwitch then longestSwitch = #aSwitch end
  end
  longestSwitch = longestSwitch + 1
  local spaces = '                                                       '
  for i, aSwitch in ipairs(lmsLongSwitches) do
    local anOption = lmsOptionHelp[aSwitch]
    local pad      = spaces:sub(1, (longestSwitch - #anOption[2]))
    print(anOption[1]..'  '..anOption[2]..pad..anOption[3])
  end
  print("\nif no target is specified then the 'default' target will be run\n")
  print("lms.os = "..lms.os)
  os.exit(0)
end)

addOption('-c', '--no-clear-screen', 'Do not clear screen', function()
  clearScreen = false
end)

addOption('-C', '--clear-screen', 'Clear screen', function()
  clearScreen = true
  os.execute('reset')
end)

addOption('-v', '--verbose', 'Provide extra output', function()
  verbose = true
end)

addOption('-V', '--Verbose', 'Provide extra output and clear screen', function()
  verbose = true
  os.execute('reset')
end)

addOption('-vv', '--veryVerbose', 'Provide even more output', function()
  verbose = true
  veryVerbose = true
end)

addOption('-T', '--targets', 'List all known targets', function()
  shouldListTargets = true
end)

function listTargets()
  tSort(targetList)
  for i, aTarget in ipairs(targetList) do
    aTDef = targets[aTarget]
    if aTDef then
      print(aTDef.target..':')
      if aTDef.dependencies then
        tSort(aTDef.dependencies)
        for i, aDependency in ipairs(aTDef.dependencies) do
          print('  '..aDependency)
        end
      else
        print('  no dependencies')
      end
    end
  end
  os.exit(0)
end

targetsToRun = { }

local function parseArguments()
  for i, anArg in ipairs(arg) do
    local key    = anArg:gsub('=.*$', '')
    local value  = anArg:gsub('^[^=]*=', '')
    if key == value then value = nil end
    optionAction = lmsOption[key]
    if optionAction and type(optionAction) == 'function' then
      optionAction(key, value)
    else
      tInsert(targetsToRun, anArg)
    end
  end
  if #targetsToRun < 1 then
    tInsert(targetsToRun, 'default')
  end
end

local function runTargets()
  for i, aTarget in ipairs(targetsToRun) do
    mustHaveTarget(aTarget)
    runTarget(aTarget)
  end
end

function tCopy(origTable)
  if type(origTable) ~= 'table' then return origTable end
  
  local newTable = {}
  for i, aValue in ipairs(origTable) do
    tInsert(newTable, aValue)
  end
  for aKey, aValue in pairs(origTable) do
    newTable[aKey] = aValue
  end
  return newTable
end

-- merge a sequence of hash tables in order...
function hMerge(...)
  local newHash = { }
  for i, aHash in ipairs{...} do
    if type(aHash) == 'table' then
      for aKey, aValue in pairs(aHash) do
        if type(aValue) == 'table' then
          newHash[aKey] = tCopy(aValue)
        else
          newHash[aKey] = aValue
        end
      end
    end
  end
  return newHash
end

-- merge a sequence of arrays in order...
function aAppend(...)
  local newArray = { }
  for i, anArray in ipairs{...} do
    if type(anArray) == 'table' then
      for j, aValue in ipairs(anArray) do
        if type(aValue) == 'table' then
          tInsert(newArray, tCopy(aValue))
        else
          tInsert(newArray, aValue)
        end
      end
    end
  end
  return newArray
end

-- Create the standard targets

cleanTargets   = cleanTargets   or { }
clobberTargets = clobberTargets or { }
docTargets     = docTargets     or { }
buildTargets   = buildTargets   or { }
headerTargets  = headerTargets  or { }
installTargets = installTargets or { }
diffTargets    = diffTargets    or { }
testTargets    = testTargets    or { }

function nameCleanTarget(theTarget)
  return 'clean-'..theTarget
end

function cleanAllTargets(cDef)
  if cDef.dependencies then
    for i, aDep in ipairs(cDef.dependencies) do
        local aCmd = 'rm -rf '..aDep:gsub('^clean%-', '')
      lmsMessageCont(aCmd)
      os.execute(aCmd)
    end
  end
  return true
end

target{
  target       = 'clean',
  dependencies = cleanTargets,
  command      = cleanAllTargets
}

function nameClobberTarget(theTarget)
  return 'clobber-'..theTarget
end

tInsert(clobberTargets, nameClobberTarget('buildDir'))
tInsert(clobberTargets, nameClobberTarget('installDir'))

function clobberAllTargets(cDef)
  runTarget('clean')
  lmsMessage('clobbering...')
  if cDef.dependencies then
    for i, aDep in ipairs(cDef.dependencies) do
        local aCmd = 'rm -rf '..aDep:gsub('^clobber%-', '')
      lmsMessageCont(aCmd)
      os.execute(aCmd)
    end
  end
  return true
end

target{
  target       = 'clobber',
  dependencies = clobberTargets,
  command      = clobberAllTargets
}

target{'doc',     docTargets}
target{'build',   buildTargets}
target{'headers', headerTargets}
target{'install', installTargets}
target{'diff',    diffTargets}
target{'tests',   testTargets}
target{'default', buildTargets}

parseArguments()

-- load the user's LMS file

require 'lmsfile'

if shouldListTargets then listTargets() end

-- execute it!

if clearScreen then os.execute('reset') end
runTargets()
