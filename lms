#!/usr/bin/env lua

-- Start with some local convenience functions

local tConcat = table.concat
local tInsert = table.insert
local tRemove = table.remove
local tSort   = table.sort
local getEnv  = os.getenv
local lfs     = require 'lfs'

-- Now update the require search paths to ensure lms standard paths will 
-- be searched 

package.path = tConcat({
  './?',
  './luaLibs/?',
  './luaLibs/?.lua',
  getEnv('HOME')..'/.lms/?',
  getEnv('HOME')..'/.lms/?.lua',
  package.path
},';')

package.cpath =
  './luaLibs/?.so;'..os.getenv('HOME')..'/.lms/?.so;'..package.cpath

-- Now create a collection of global functions to act as a DSL 

targets = {}

alreadyRun = {}

verbose = false

function lmsError(aMessage)
  print('ERROR: '..aMessage)
  os.exit(-1)
end

function target(tDef)
  if 0 < #tDef then tDef.target       = tRemove(tDef, 1) end
  if 0 < #tDef then tDef.dependencies = tRemove(tDef, 1) end
  if 0 < #tDef then tDef.command      = tRemove(tDef, 1) end
  if not tDef.target then lmsError('target method did not supply a target') end
  targets[tDef.target] = tDef
end

function needsToBuild(aTargetDef)
  tTime = lfs.attributes(aTargetDef.target, 'modification')
  if not tTime then return true end
  
  for i, aDependency in ipairs(aTargetDef.dependencies) do
    dTime = lfs.attributes(aDependency, 'modification')
    if not dTime then lmsError('missing dependency: ['..aDependency..']') end
    if dTime < tTime then return true end
  end
  return false
end

function mustHaveTarget(targetToRun)
  local aTarget = targets[targetToRun]
  if not aTarget then
    lmsError(' no target found for ['..targetToRun..']')
  end
end

function runTarget(targetToRun)
  if alreadyRun[targetToRun] then return end
  
  if verbose then print('checking: '..targetToRun) end
  
  local aTarget = targets[targetToRun]
  if not aTarget then return end  
  
  for i, aDependency in ipairs(aTarget.dependencies) do
    runTarget(aDependency)
  end

  if aTarget.command and needsToBuild(aTarget) then
    if type(aTarget.command) == 'string' then
      if verbose then 
        print('building ['..aTarget.target..'] using ['..aTarget.command..']')
      end
      if not os.execute(aTarget.command) then
        lmsError('could not run ['..aTarget.command..']')
      end
    elseif type(aTarget.command) == 'function' then
      if verbose then 
        print('building ['..aTarget.target..']')
      end
      if not aTarget.command(aTarget) then
        lmsError('could not run command for ['..aTarget.target..']')
      end
    else
      lmsError('the command for target ['..aTarget.target..'] MUSt be either a string or a function.')
    end
  end
  alreadyRun[targetToRun] = true
end

-- Now we create a helper tools to be able to deal with options 

lmsOptionHelp   = { }
lmsLongSwitches = { }
lmsOption       = { }
runDefault      = true

function addOption( shortSwitch, longSwitch, description, action)
  lmsOptionHelp[longSwitch] = { shortSwitch, longSwitch, description, action }
  tInsert(lmsLongSwitches, longSwitch)
  lmsOption[shortSwitch] = action
  lmsOption[longSwitch]  = action
end

addOption('-h', '--help', 'Provide this list of options', function()
  runDefault = false
  print('lms -- Lua Make System\n')
  print('usage: lms [options] [targets]\n')
  print('where: targets is a space delimited list of lms targets to be run,')
  print('and options is one of the following:\n')
  tSort(lmsLongSwitches)
  local longestSwitch = 0
  for i, aSwitch in ipairs(lmsLongSwitches) do
    if longestSwitch < #aSwitch then longestSwitch = #aSwitch end
  end
  longestSwitch = longestSwitch + 1
  local spaces = '                                                       '
  for i, aSwitch in ipairs(lmsLongSwitches) do
    local anOption = lmsOptionHelp[aSwitch]
    local pad      = spaces:sub(1, (longestSwitch - #anOption[2]))
    print(anOption[1]..'  '..anOption[2]..pad..anOption[3])
  end
  print("\nif no target is specified then the 'default' target will be run")
  os.exit(0)
end)

addOption('-v', '--verbose', 'Provide extra output', function()
  verbose = true
end)

local function parseAndRunArguments()
  runDefault = true
  for i, anArg in ipairs(arg) do
    local key    = anArg:gsub('=.*$', '')
    local value  = anArg:gsub('^[^=]*=', '')
    if key == value then value = nil end
    optionAction = lmsOption[key]
    if optionAction and type(optionAction) == 'function' then
      optionAction(key, value)
    else
      runDefault = false
      mustHaveTarget(anArg)
      runTarget(anArg)
    end
  end
  if runDefault then
    mustHaveTarget('default')
    runTarget('default')
  end
end

-- load the user's LMS file

require 'lmsfile'

-- execute it!

parseAndRunArguments()