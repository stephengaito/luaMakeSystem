#!/usr/bin/env texlua

-- Start with some local convenience functions

tConcat = table.concat
tInsert = table.insert
tRemove = table.remove
tSort   = table.sort
getEnv  = os.getenv
lfs     = require 'lfs'

-- Now see if we can load the lua libuv bindings (luv)

-- The following conditional require is adapted from: shuva's answer to 
--  "How to check if a module exists in Lua?"
-- see: http://stackoverflow.com/a/22686090

--local hasluv, luvLocal = pcall(require, "luv")
--if not hasluv then luvLocal = { } end
--luv = luvLocal
luv = {}

-- Now update the require search paths to ensure lms standard paths will 
-- be searched 

directorySeparator = package.config:sub(1,1)

function setEnvironment(envKey, envValue)
  os.setenv(envKey, envValue)
end

function setEnvironmentDefault(envKey, envValue)
  if type(os.getenv(envKey)) == 'nil' then
    os.setenv(envKey, envValue)
  end
end

function clearEnvironment(envKey)
  os.setenv(envKey, nil)
end

function replaceEnvironmentVarsInPath( aPath )
  aNewPath = aPath:gsub('<([^>]+)>', os.env)
  return(aNewPath)
end

function makePath(pathTable)
  return tConcat(pathTable, directorySeparator)
end

function getBaseDirPath(aPath)
  basePath = aPath:gsub('[^/\\]*$', '')
  basePath = basePath:gsub('[/\\]$', '')
  return basePath
end

function changeFileExtension(aPath, newExt)
  newPath = aPath:gsub('%.[^%.]+$', newExt)
  return newPath
end

package.path = tConcat({
  makePath{'.', '?'},
  makePath{'.', 'lib', '?'},
  makePath{'.', 'lib', '?.lua'},
  makePath{getEnv('HOME'), '.luaMakeSystem', '?'},
  makePath{getEnv('HOME'), '.luaMakeSystem','?.lua'},
  package.path
},';')

package.cpath = tConcat({
  makePath{'.', 'luaLibs', '?.so'},
  makePath{getEnv('HOME'), '.luaMakeSystem', '?.so'},
  package.cpath
}, ';')

-- Now load any user's local lms configuration

-- The following conditional require is adapted from: shuva's answer to 
--  "How to check if a module exists in Lua?"
-- see: http://stackoverflow.com/a/22686090

local hasLmsConfig, lmsConfig = pcall(require, "lmsConfig")
if not hasLmsConfig then lmsConfig = { } end
lms = lmsConfig

-- Now define some functions to help communicate with the user 

currentDir = lfs.currentdir()
currentDir = currentDir:gsub('(.*[/\\])', '')

clearScreen = lms.clearScreen or true
verbose     = lms.verbose     or false
veryVerbose = lms.veryVerbose or false
recurse     = lms.recurse     or true
dirPrefix   = lms.dirPrefix   or currentDir

function lmsError(aMessage)
  print('ERROR: '..aMessage)
  if lms.fileInfo then saveFileInfo(lms.fileInfo) end
  os.exit(-1)
end

function lmsMessage(...)
  if verbose then
    print('---------------------------------------')
    for i, aMessage in ipairs({...}) do
      print(aMessage)
    end
  end
end

function lmsMessageCont(...)
  if verbose then
    for i, aMessage in ipairs({...}) do
      print(aMessage)
    end
  end
end

function lmsMessageVery(...)
  if veryVerbose then
    for i, aMessage in ipairs({...}) do
      print(aMessage)
    end
  end
end

-- Now compute the OS (which can be used to require different versions of 
-- the lms modules) 

function getOutputFromCmd(aCmd)
  lmsMessageVery('getting output from: ['..aCmd..']')
  local proc = io.popen(aCmd..' 2>&1', 'r')
  if not proc then return '' end
  local result = proc:read('*a')
  proc:close()
  local result = result:gsub('\n$','')
  return result
end

if package.config:sub(1,1) == '\\' then
  lms.os = 'Windows'
else
  lms.os = getOutputFromCmd('uname -s')
end

-- Now create a collection of global functions to act as a DSL 

targets    = {}
targetList = {}
alreadyRun = {}

function runCmdIn(cmd, subDir)
  subDirPath = subDir
  if cmd:find('^lms') then
    cmd = makePath { cmd, subDir }
  end
  subDirPath = makePath { dirPrefix, subDir }
  local curDir = lfs.currentdir()
  print('\n========================================================')
  print('working in ['..subDirPath..']')
  print('running    ['..cmd..']')
  lfs.chdir(subDir)
  if not executeCmd(cmd) then
    print('FAILED to run: ['..cmd..']')
    if lms.fileInfo then saveFileInfo(lms.fileInfo) end
    os.exit(-1)
  end
  lfs.chdir(curDir)
end

function executeCmd(aCmd)
  if luv.spawn then
    if useLUV then
      lmsMessage('running: ['..aCmd..'] using luv.spawn BUT NOT YET')
      return os.execute(aCmd)
    else
      lmsMessage('running: ['..aCmd..'] using os.execute BUT COULD USE LUV')
      return os.execute(aCmd)
    end
  else
    lmsMessage('running: ['..aCmd..'] using os.execute (luv not installed)')
    return os.execute(aCmd)
  end
end

function chDir(aNewDir)
  if not lfs.chdir(aNewDir) then 
    lmsError('could not change directory to: ['..aNewDir..']')
  end
end

function collectSubDirectories(ignoredDirs)
  subDirs = { }
  for entry in lfs.dir('.') do
    if not entry:match('^%..*$') and
      (lfs.attributes(entry, 'mode') == 'directory') and
      not ignoredDirs:match(entry) then
      tInsert(subDirs, entry)
    end
  end
  tSort(subDirs)
  return subDirs
end

function addDependency(aTarget, aDependency)
  if not targets[aTarget] then
    targets[aTarget] = {
      dependencies = { },
      target       = aTarget
    }
    tInsert(targetList, aTarget)
  end
  if not aHasValue(targets[aTarget]['dependencies'], aDependency) then
    tInsert(targets[aTarget]['dependencies'], aDependency)
  end
end

function target(tDef)
  if 0 < #tDef then tDef.target       = tRemove(tDef, 1) end
  if 0 < #tDef then tDef.dependencies = tRemove(tDef, 1) end
  if 0 < #tDef then tDef.command      = tRemove(tDef, 1) end
  if not tDef.target then 
    lmsError(debug.traceback('target method did not supply a target')) 
  end
  if targets[tDef.target] then -- first definition wins!
    print('Sorry the target: ['..tDef.target..'] already exists -- ignored!')
    showTarget(tDef.target)
    print("The NEW target is:")
    print(prettyPrint(tDef))
    print("=======================================")
  else
    tDef['coroutine'] = coroutine.create(runTarget)
    targets[tDef.target] = tDef
    tInsert(targetList, tDef.target)
  end
  tDef.recurse = tDef.recurse or true
  return tDef.target
end

function getTargetFor(aTarget)
  return targets[aTarget]
end

sha2 = require 'lms.sha2'

function computeSha256(aFilePath)
  local fileIO    = io.open(aFilePath, 'rb')
  if not fileIO then
    return nil
  end
  local appendSha = sha2.sha256()
  repeat
    local someBytes = fileIO:read(2^12)
    appendSha(someBytes)
  until not someBytes
  return appendSha()
end

function needsToBuild(aTargetDef)
  if type(aTargetDef['mustBuild']) ~= 'nil' then
    lmsMessage('  must build')
    return true
  end

  tTime = lfs.attributes(aTargetDef.target, 'modification')
  if (tTime) then
    lmsMessageCont('  ('..os.date('%Y/%m/%d %H:%M:%S', tTime)..')['..tTime..']')
  else
    lmsMessageCont('  (does not exist)')
  end
  if not tTime then 
    lmsMessage('need to build ['..aTargetDef.target..']\nsince target does not exist')
    return true
  end

  local newFileSha256 = computeSha256(aTargetDef.target)
  local oldFileSha256 = lms.fileInfo[aTargetDef.target] or ""
  if newFileSha256 == oldFileSha256 then
    lmsMessageCont('  (sha256 match so no need to rebuild)')
    return false
  end
  lms.fileInfo[aTargetDef.target] = newFileSha256

  for i, aDependency in ipairs(aTargetDef.dependencies) do
    if lfs.attributes(aDependency, 'mode') ~= 'directory' then
      dTime = lfs.attributes(aDependency, 'modification')
      if not dTime then lmsError('missing dependency: ['..aDependency..']') end
      if dTime > tTime then
        lmsMessage(
          'need to build ['..aTargetDef.target..']',
          'since ['..aDependency..']',
          'is newer ('..os.date('%Y/%m/%d %H:%M:%S', dTime)..')['..dTime..']',
          'than the target ('..os.date('%Y/%m/%d %H:%M:%S', tTime)..')['..tTime..']'
          )
        return true
      end
    end
  end
  lmsMessageVery('all dependencies older than target')
  return false
end

local toStr   = tostring

function saveFileInfo(fileInfo)
  fileInfoFile = io.open('lmsFileInfo', 'w')
  fileInfoFile:write('-- This is a automatically generated lua module\n')
  fileInfoFile:write('-- it is NOT wise to make any changes\n\n')
  fileInfoFile:write('local M = {}\n')
  for key, value in pairs(fileInfo) do
    fileInfoFile:write('  M["'..key..'"] = "'..value..'"\n')
  end
  fileInfoFile:write('return M\n')
  fileInfoFile:close()
end

local function compareKeyValues(a, b)
  return (a[1] < b[1])
end

function prettyPrint(anObj, indent)
  local result = ""
  indent = indent or ""
  if type(anObj) == 'nil' then
    result = 'nil'
  elseif type(anObj) == 'boolean' then
    if anObj then result = 'true' else result = 'false' end
  elseif type(anObj) == 'number' then
    result = toStr(anObj)
  elseif type(anObj) == 'string' then
    result = '"'..anObj..'"'
  elseif type(anObj) == 'function' then
    result = toStr(anObj)
  elseif type(anObj) == 'userdata' then
    result = toStr(anObj)
  elseif type(anObj) == 'thread' then
    result = toStr(anObj)
  elseif type(anObj) == 'table' then
    local origIndent = indent
    indent = indent..'  '
    result = '{\n'
    for i, aValue in ipairs(anObj) do
      result = result..indent..prettyPrint(aValue, indent)..',\n'
    end
    local theKeyValues = { }
    for aKey, aValue in pairs(anObj) do
      if type(aKey) ~= 'number' or aKey < 1 or #anObj < aKey then
        tInsert(theKeyValues,
          { prettyPrint(aKey), aKey, prettyPrint(aValue, indent) })
      end
    end
    tSort(theKeyValues, compareKeyValues)
    for i, aKeyValue in ipairs(theKeyValues) do
      result = result..indent..'['..aKeyValue[1]..'] = '..aKeyValue[3]..',\n'
    end
    result = result..origIndent..'}'
  else
    result = 'UNKNOWN TYPE: ['..toStr(anObj)..']'
  end
  return result
end

function showTarget(targetToRun)
  print("=======================================")
  print("The target for: ["..targetToRun.."]")
  print(prettyPrint(targets[targetToRun]))
  print("=======================================")
end

function mustHaveTarget(targetToRun)
  local aTarget = targets[targetToRun]
  if not aTarget then
    lmsError(' no target found for ['..targetToRun..']')
  end
end

function runTarget(targetToRun)
  if alreadyRun[targetToRun] then
    lmsMessageVery('already run '..targetToRun)
    return
  end
  
  lmsMessage('checking: '..targetToRun)
  
  local aTarget = targets[targetToRun]
  if not aTarget then
    lmsMessageVery('nothing to do')
    return
  end  

  if aTarget.dependencies then
    for i, aDependency in ipairs(aTarget.dependencies) do
      depCoroutine = targets[aDependency]['coroutine']
      if depCoroutine then
        coroutine.resume(depCoroutine, aDependency)
      else
        lmsError('no coroutine created for '..aDependency)
        -- runTarget(aDependency)
      end
    end
  else
    lmsMessageCont('no dependencies key found')
  end

  coroutine.yield()
  
  lmsMessage('(re)checking: '..targetToRun)
  if aTarget.command then
    lmsMessageCont('  has command ('..toStr(aTarget.command)..')')
  else
    lmsMessageCont('  has NO command')
  end
  
  if aTarget.command and needsToBuild(aTarget) then
    if type(aTarget.command) == 'string' then
      lmsMessageCont(
       'building ['..aTarget.target..']\nusing ['..aTarget.command..']'
      )
      if not os.execute(aTarget.command) then
        lmsError('could not run ['..aTarget.command..']')
      end
    elseif type(aTarget.command) == 'function' then
      lmsMessageCont('building ['..aTarget.target..']')
      if not aTarget.command(aTarget) then
        lmsError('could not run command for ['..aTarget.target..']')
      end
    else
      lmsError('the command for target ['..aTarget.target..'] MUSt be either a string or a function.')
    end
  end
  alreadyRun[targetToRun] = true
end

-- Now we create some general helper tools

function getParentPath(aPath)
  local parentPath =
    aPath:gsub(directorySeparator..'?[^'..directorySeparator..']*$', '')
--  print('getParentPath: ['..aPath..']->['..parentPath..']')
  if #parentPath < 1 then parentPath = nil end
  return parentPath
end

local function createPath(aTarget)
  return lfs.mkdir(aTarget.target)
end

function ensurePathExists(aPath)
  if not aPath then return '' end
  local paths = { }
  local parentPath = getParentPath(aPath)
  if parentPath then
    ensurePathExists(parentPath)
    paths = { parentPath }
  end
  pathTarget = getTargetFor(aPath)
  if not pathTarget then
    pathTarget = target({
      dependencies = paths,
      target       = aPath,
      command      = createPath,
      creator      = 'ensurePathExists'
    })
  end
  return pathTarget
end

-- Now we create a helper tools to be able to deal with options 

lmsOptionHelp     = { }
lmsLongSwitches   = { }
lmsOption         = { }
runDefault        = true
shouldListTargets = false
useLUV            = true

function addOption( shortSwitch, longSwitch, description, action)
  lmsOptionHelp[longSwitch] = { shortSwitch, longSwitch, description, action }
  tInsert(lmsLongSwitches, longSwitch)
  lmsOption[shortSwitch] = action
  lmsOption[longSwitch]  = action
end

addOption('-h', '--help', 'Provide this list of options', function()
  runDefault = false
  print('lms -- Lua Make System\n')
  print('usage: lms [options] [targets]\n')
  print('where: targets is a space delimited list of lms targets to be run,')
  print('and options is one of the following:\n')
  tSort(lmsLongSwitches)
  local longestSwitch = 0
  for i, aSwitch in ipairs(lmsLongSwitches) do
    if longestSwitch < #aSwitch then longestSwitch = #aSwitch end
  end
  longestSwitch = longestSwitch + 1
  local spaces = '                                                       '
  for i, aSwitch in ipairs(lmsLongSwitches) do
    local anOption = lmsOptionHelp[aSwitch]
    local pad      = spaces:sub(1, (longestSwitch - #anOption[2]))
    print(anOption[1]..'  '..anOption[2]..pad..anOption[3])
  end
  print("\nif no target is specified then the 'default' target will be run\n")
  print("lms.os = "..lms.os)
  os.exit(0)
end)

addOption('-d', '--directory-prefix', 'The current directory prefix',
  function(key, value)
    dirPrefix = value
  end
)

addOption('-c', '--no-clear-screen', 'Do not clear screen', function()
  clearScreen = false
end)

addOption('-C', '--clear-screen', 'Clear screen', function()
  clearScreen = true
  os.execute('reset')
end)

addOption('-r', '--no-recurse', 'Do not recurse into sub-directories', function()
  recurse = false
end)

addOption('-R', '--recurse', 'Recurse into sub-directories', function()
  recurse = true
end)

addOption('-v', '--verbose', 'Provide extra output', function()
  verbose = true
end)

addOption('-V', '--Verbose', 'Provide extra output and clear screen', function()
  verbose = true
  os.execute('reset')
end)

addOption('-vv', '--veryVerbose', 'Provide even more output', function()
  verbose = true
  veryVerbose = true
end)

addOption('-T', '--targets', 'List all known targets', function()
  shouldListTargets = true
end)

addOption('-p', '--parallel', 'Run external commands in parallel if at all possible (requires "luarocks install luv")', function()
  useLUV = true
end)

addOption('-s', '--sequential', 'Run external commands sequentially (one at a time)', function()
  useLUV = false
end)
function listTargets()
  tSort(targetList)
  for i, aTarget in ipairs(targetList) do
    aTDef = targets[aTarget]
    if aTDef then
      print(aTDef.target..':')
      if aTDef.command then
        print('  '..prettyPrint(aTDef.command))
      else
        print('  no command')
      end
      if aTDef.dependencies then
        tSort(aTDef.dependencies)
        for i, aDependency in ipairs(aTDef.dependencies) do
          print('  '..aDependency)
        end
      else
        print('  no dependencies')
      end
    end
  end
  os.exit(0)
end

targetsToRun = { }

local function parseArguments()
  for i, anArg in ipairs(arg) do
    local key    = anArg:gsub('=.*$', '')
    local value  = anArg:gsub('^[^=]*=', '')
    if key == value then value = nil end
    optionAction = lmsOption[key]
    if optionAction and type(optionAction) == 'function' then
      optionAction(key, value)
    else
      tInsert(targetsToRun, anArg)
    end
  end
  if #targetsToRun < 1 then
    tInsert(targetsToRun, 'default')
  end
end

local function runTargets()
  for i, aTarget in ipairs(targetsToRun) do
    mustHaveTarget(aTarget)
    targetCoroutine = targets[aTarget]['coroutine']
    if targetCoroutine then
      coroutine.resume(targetCoroutine, aTarget)
    else
      lmsError('no coroutine created for '..aTarget)
      -- runTarget(aTarget)
    end
  end
end

local function checkTargets()
  here be dragons!!!!
end

function tCopy(origTable)
  if type(origTable) ~= 'table' then return origTable end
  
  local newTable = {}
  for i, aValue in ipairs(origTable) do
    tInsert(newTable, aValue)
  end
  for aKey, aValue in pairs(origTable) do
    newTable[aKey] = aValue
  end
  return newTable
end

-- merge a sequence of hash tables in order...
function hMerge(...)
  local newHash = { }
  for i, aHash in ipairs{...} do
    if type(aHash) == 'table' then
      for aKey, aValue in pairs(aHash) do
        if type(aValue) == 'table' then
          newHash[aKey] = tCopy(aValue)
        else
          newHash[aKey] = aValue
        end
      end
    end
  end
  return newHash
end

-- merge a sequence of arrays in order...
function aAppend(...)
  local newArray = { }
  for i, anArray in ipairs{...} do
    if type(anArray) == 'table' then
      for j, aValue in ipairs(anArray) do
        if type(aValue) == 'table' then
          tInsert(newArray, tCopy(aValue))
        else
          tInsert(newArray, aValue)
        end
      end
    end
  end
  return newArray
end

function aHasValue(anArray, aValue)
    for index, value in ipairs(anArray) do
        if value == aValue then
            return true
        end
    end
    return false
end

function aInsertOnce(anArray, aValue)
  if not aHasValue(anArray, aValue) then
    tInsert(anArray, aValue)
  end
end

-- find documents

function findDocuments(aDef)
  if type(aDef['docFiles']) ~= 'nil' then return end

  aDef['findRegexp'] = aDef['findRegexp'] or ".*\\.tex\\|.*Bib\\.lua"
  aDef['subDirs']    = aDef['subDirs']    or aDef['docDir']

  local docFiles = { }
  for i, aDir in ipairs(aDef['subDirs']) do
    local findCmd  = 'find '..aDir..' -iregex "'..aDef['findRegexp']..'"'
    lmsMessageVery('Dynamically finding documents using ['..findCmd..']')
    local texFileList = io.popen(findCmd)
    for docTexFilePath in texFileList:lines('*l') do
      docTexFilePath = './'..docTexFilePath
      table.insert(docFiles, docTexFilePath)
    end
  end
  aDef.docFiles = docFiles
end

-- Deal with sub-directory recursion

function doNotRecurseTarget(aTarget)
  if type(targets[aTarget]) ~= 'nil' then
    targets[aTarget].recurse = false
  end
end

function findSubDirs(aDef)
  if type(aDef['subDirs']) ~= 'nil' then
    if type(aDef['subDirs']) ~= 'table' then
      aDef['subDirs'] = { aDef['subDirs'] }
    end
    return
  end

  aDef['ignoreDirs'] = aDef['ignoreDirs'] or { 'releases', 'buildDir', 'bin' }

  local subDirs = { }
  local ignoreDirs = { }
  for i, aDir in ipairs(aDef['ignoreDirs']) do
    ignoreDirs[aDir] = true
  end
  for entry in lfs.dir('.') do
    if not entry:match('^%..*$') and
       (lfs.attributes(entry, 'mode') == 'directory') and
       not ignoreDirs[entry] then
      table.insert(subDirs, entry)
    end
  end
  aDef['subDirs'] = subDirs
end

function recurseCurrentTarget(aDef)
  if type(aDef['subDirs']) ~= 'table' then
    print('  No subdirs to recurse into...')
    return
  end

  if type(aDef['recurseCmd']) ~= 'string' then
    print('  No recurse command to run...')
    return
  end

  tSort(aDef['subDirs'])
  for i, subDir in ipairs(aDef['subDirs']) do
    runCmdIn(aDef['recurseCmd'], subDir)
  end

  print("\n========================================================")
  print('finished running ['..aDef['recurseCmd']..']')
--  curDir = lfs.currentdir()
--  curDir = curDir:gsub('(.*[/\\])', '')
  print('  in all sub dirs of ['..dirPrefix..']')
  print("")
  return true
end

function recurseTargets(aDef)
  if not recurse then return end

  local recurseDefaults = {
    ignoreDirs = { 'release', 'buildDir', 'bin', 'doc' }
  }
  aDef = hMerge(recurseDefaults, aDef)
  findSubDirs(aDef)

  recurseTargets = { }
  for i, aTarget in ipairs(targetsToRun) do
    if targets[aTarget].recurse then
      anRTargetName = aTarget..'-recurse'
      anRTargetDef  = targets[anRTargetName] or { }

      anRTargetDef.target = anRTargetName
      anRTargetDef.dependencies =
        anRTargetDef.dependencies or { }

      anRTargetDef.command    = recurseCurrentTarget
      anRTargetDef.subDirs    = aDef['subDirs']
      local switches          = ''
      if verbose then switches = switches .. ' -v ' end
      if veryVerbose then switches = switches .. ' -vv ' end
      recurseCmd              = 'lms -c ' .. switches .. aTarget .. ' -d=' .. dirPrefix
      anRTargetDef.recurseCmd = recurseCmd
      anRTargetDef.mustBuild  = true

      targets[anRTargetName] = anRTargetDef

      tInsert(recurseTargets, anRTargetName)
    end
  end

  for i, aTarget in ipairs(recurseTargets) do
    tInsert(targetsToRun, aTarget)
  end  
end

-- Create the standard targets

function createNewTarget(targetName, targetVarName, targetCommand)
  _G[targetVarName] = _G[targetVarName] or { }
  target{
    target       = targetName,
    dependencies = _G[targetVarName],
    command      = targetCommand,
    creator      = 'createNewTarget'
  }
end

function nameCleanTarget(theTarget)
  return 'clean-'..theTarget
end

function cleanAllTargets(cDef)
  if cDef.dependencies then
    for i, aDep in ipairs(cDef.dependencies) do
        local aCmd = 'rm -rf '..aDep:gsub('^clean%-', '')
      lmsMessageCont(aCmd)
      os.execute(aCmd)
    end
  end
  return true
end

createNewTarget('clean', 'cleanTargets', cleanAllTargets)

function nameClobberTarget(theTarget)
  return 'clobber-'..theTarget
end

function clobberAllTargets(cDef)
  runTarget('clean')
  lmsMessage('clobbering...')
  if cDef.dependencies then
    for i, aDep in ipairs(cDef.dependencies) do
        local aCmd = 'rm -rf '..aDep:gsub('^clobber%-', '')
      lmsMessageCont(aCmd)
      os.execute(aCmd)
    end
  end
  return true
end

createNewTarget('clobber', 'clobberTargets', clobberAllTargets)

tInsert(clobberTargets, nameClobberTarget('buildDir'))
tInsert(clobberTargets, nameClobberTarget('installDir'))
tInsert(clobberTargets, nameClobberTarget('lmsFileInfo'))

createNewTarget('doc',     'docTargets')
createNewTarget('bib',     'bibTargets')
createNewTarget('code',    'codeTargets')
createNewTarget('headers', 'headerTargets')
createNewTarget('build',   'buildTargets')
createNewTarget('install', 'installTargets')
createNewTarget('diff',    'diffTargets')
createNewTarget('tests',   'testTargets')
createNewTarget('default', 'buildTargets')

parseArguments()

-- load the user's LMS file

require 'lmsfile'

if shouldListTargets then listTargets() end

-- execute it!

-- The following conditional require is adapted from: shuva's answer to 
--  "How to check if a module exists in Lua?"
-- see: http://stackoverflow.com/a/22686090

local hasLmsFileInfo, lmsFileInfo = pcall(require, "lmsFileInfo")
if not hasLmsFileInfo then
  print(lmsFileInfo)
  lmsFileInfo = { }
end
lms.fileInfo = lmsFileInfo


--if clearScreen then os.execute('reset') end

runTargets()

checkTargets()

saveFileInfo(lms.fileInfo)
