#!/usr/bin/env texlua

-- Start with some local convenience functions

tConcat = table.concat
tInsert = table.insert
tRemove = table.remove
tSort   = table.sort
toStr   = tostring
getEnv  = os.getenv
lfs     = require 'lfs'

-- Now update the require search paths to ensure lms standard paths will 
-- be searched 

directorySeparator = package.config:sub(1,1)

function setEnvironment(envKey, envValue)
  os.setenv(envKey, envValue)
end

function setEnvironmentDefault(envKey, envValue)
  if type(os.getenv(envKey)) == 'nil' then
    os.setenv(envKey, envValue)
  end
end

function clearEnvironment(envKey)
  os.setenv(envKey, nil)
end

function replaceEnvironmentVarsInPath( aPath )
  aNewPath = aPath:gsub('<([^>]+)>', os.env)
  return(aNewPath)
end

function makePath(pathTable)
  return tConcat(pathTable, directorySeparator)
end

luaMakeSystemDir = makePath{ getEnv('HOME'), '.luaMakeSystem'}

function getBaseDirPath(aPath)
  basePath = aPath:gsub('[^/\\]*$', '')
  basePath = basePath:gsub('[/\\]$', '')
  return basePath
end

function changeFileExtension(aPath, newExt)
  newPath = aPath:gsub('%.[^%.]+$', newExt)
  return newPath
end

package.path = tConcat({
  makePath{'.', '?'},
  makePath{'.', 'lib', '?'},
  makePath{'.', 'lib', '?.lua'},
  makePath{luaMakeSystemDir, '?'},
  makePath{luaMakeSystemDir,'?.lua'},
  package.path
},';')

package.cpath = tConcat({
  makePath{'.', 'luaLibs', '?.so'},
  makePath{luaMakeSystemDir, '?.so'},
  package.cpath
}, ';')

-- Now load any user's local lms configuration

-- The following conditional require is adapted from: shuva's answer to 
--  "How to check if a module exists in Lua?"
-- see: http://stackoverflow.com/a/22686090

local hasLmsConfig, lmsConfig = pcall(require, "lmsConfig")
if not hasLmsConfig then lmsConfig = { } end
lms = lmsConfig

-- Now see if we can load the lua libuv bindings (luv)

local hasluv, luvLocal = pcall(require, "luv")
if not hasluv then luvLocal = { } end
luv = luvLocal

-- Now define some functions to help communicate with the user 

currentDir = lfs.currentdir()
currentDir = currentDir:gsub('(.*[/\\])', '')

clearScreen = lms.clearScreen or true
verbose     = lms.verbose     or 0
recurse     = lms.recurse     or true
dirPrefix   = lms.dirPrefix   or currentDir
logDir      = lms.logDir      or '/tmp'
local aTmpName = os.tmpname()
logPrefix   = lms.logPrefix   or
  aTmpName:gsub(
    '%/tmp%/lua_',
    logDir..'/lms_'..os.date('%Y-%m-%d_%H-%M-%S')..'_'..currentDir..'_'
  )
os.remove(aTmpName)
useLUV      = lms.useLUV      or false

local function compareKeyValues(a, b)
  return (a[1] < b[1])
end

function prettyPrint(anObj, indent)
  local result = ""
  indent = indent or ""
  if type(anObj) == 'nil' then
    result = 'nil'
  elseif type(anObj) == 'boolean' then
    if anObj then result = 'true' else result = 'false' end
  elseif type(anObj) == 'number' then
    result = toStr(anObj)
  elseif type(anObj) == 'string' then
    result = '"'..anObj..'"'
  elseif type(anObj) == 'function' then
    result = toStr(anObj)
  elseif type(anObj) == 'userdata' then
    result = toStr(anObj)
  elseif type(anObj) == 'thread' then
    result = toStr(anObj)
  elseif type(anObj) == 'table' then
    local origIndent = indent
    indent = indent..'  '
    result = '{\n'
    for i, aValue in ipairs(anObj) do
      result = result..indent..prettyPrint(aValue, indent)..',\n'
    end
    local theKeyValues = { }
    for aKey, aValue in pairs(anObj) do
      if type(aKey) ~= 'number' or aKey < 1 or #anObj < aKey then
        tInsert(theKeyValues,
          { prettyPrint(aKey), aKey, prettyPrint(aValue, indent) })
      end
    end
    tSort(theKeyValues, compareKeyValues)
    for i, aKeyValue in ipairs(theKeyValues) do
      result = result..indent..'['..aKeyValue[1]..'] = '..aKeyValue[3]..',\n'
    end
    result = result..origIndent..'}'
  else
    result = 'UNKNOWN TYPE: ['..toStr(anObj)..']'
  end
  return result
end

function lmsError(aMessage)
  print('ERROR: '..aMessage)
  saveFileInfo()
  os.exit(-1)
end

function lmsMessage(...)
  if 0 < verbose then
    local messages = ...
    if type(messages) ~= 'table' then
      messages = { messages }
    end
    print('---------------------------------------')
    for i, aMessage in ipairs(messages) do
      print(aMessage)
    end
  end
end

function lmsMessageDetailed(level, ...)
  if level < verbose then
    local messages = ...
    if type(messages) ~= 'table' then
      messages = { messages }
    end
    for i, aMessage in ipairs(messages) do
      print(aMessage)
    end
  end
end

function lmsMessageCont(...) lmsMessageDetailed(0, ...) end
function lmsMessageVery(...) lmsMessageDetailed(1, ...) end

-- Now we create a helper tools to be able to deal with options 

lmsOptionHelp     = { }
lmsLongSwitches   = { }
lmsOption         = { }
shouldListTargets = false

function addOption( shortSwitch, longSwitch, description, action)
  lmsOptionHelp[longSwitch] = { shortSwitch, longSwitch, description, action }
  tInsert(lmsLongSwitches, longSwitch)
  lmsOption[shortSwitch] = action
  lmsOption[longSwitch]  = action
end

addOption('-h', '--help', 'Provide this list of options', function()
  print('lms -- Lua Make System\n')
  print('usage: lms [options] [targets]\n')
  print('where: targets is a space delimited list of lms targets to be run,')
  print('and options is one of the following:\n')
  tSort(lmsLongSwitches)
  local longestSwitch = 0
  for i, aSwitch in ipairs(lmsLongSwitches) do
    if longestSwitch < #aSwitch then longestSwitch = #aSwitch end
  end
  longestSwitch = longestSwitch + 1
  local spaces = '                                                       '
  for i, aSwitch in ipairs(lmsLongSwitches) do
    local anOption = lmsOptionHelp[aSwitch]
    local pad      = spaces:sub(1, (longestSwitch - #anOption[2]))
    print(anOption[1]..'  '..anOption[2]..pad..anOption[3])
  end
  print("\nif no target is specified then the 'default' target will be run\n")
  print("lms.os = "..lms.os)
  os.exit(0)
end)

addOption('-l', '--log-prefix', 'A prefix for all logFile paths', 
  function(key, value)
    if value then
      logPrefix = value
    end
  end
)

addOption('-d', '--directory-prefix', 'The current directory prefix',
  function(key, value)
    dirPrefix = value
  end
)

addOption('-c', '--no-clear-screen', 'Do not clear screen', function()
  clearScreen = false
end)

addOption('-C', '--clear-screen', 'Clear screen', function()
  clearScreen = true
  os.execute('reset')
end)

addOption('-r', '--no-recurse', 'Do not recurse into sub-directories', function()
  recurse = false
end)

addOption('-R', '--recurse', 'Recurse into sub-directories', function()
  recurse = true
end)

addOption('-v', '--verbose', 'Provide extra output',
  function(key, value)
    value = tonumber(value)
    if type(value) ~= 'number' then value = 1 end
    verbose = value
  end
)

addOption('-V', '--Verbose', 'Provide extra output and clear screen',
  function(key, value)
    value = tonumber(value)
    if type(value) ~= 'number' then value = 1 end
    verbose = value
    os.execute('reset')
  end
)

addOption('-vv', '--veryVerbose', 'Provide even more output',
  function(key, value)
    value = tonumber(value)
    if type(value) ~= 'number' then value = 1 end
    verbose = 2
  end
)

addOption('-T', '--targets', 'List all known targets', function()
  shouldListTargets = true
end)

addOption('-p', '--parallel', 'Run external commands in parallel if at all possible (requires "luarocks install luv")', function()
  if luv.spawn then 
    useLUV = true
  else
    lmsMessage{
      'Sorry... external commands can only be run in parallel',
      ' IF the luv luarock is installed',
    }
    useLUV = false
  end
end)

addOption('-s', '--sequential', 'Run external commands sequentially (one at a time)', function()
  useLUV = false
end)

targetsToRun = { }

local function parseArguments()
  for i, anArg in ipairs(arg) do
    local key    = anArg:gsub('=.*$', '')
    local value  = anArg:gsub('^[^=]*=', '')
    if key == value then value = nil end
    optionAction = lmsOption[key]
    if optionAction and type(optionAction) == 'function' then
      optionAction(key, value)
    else
      tInsert(targetsToRun, anArg)
    end
  end
end

parseArguments()

-- Now check if we can actually use LUV

if useLUV and not luv.spawn then
  lmsMessage{
    'Sorry... external commands can only be run in parallel',
    '         IF the luv luarock is installed'
  }
  useLUV = false
end

lms.dmucsServer = ' -s '..lms.dmucsServer or ''
lms.dmucsRunner = lms.dmucsRunner or 
  makePath{ luaMakeSystemDir, 'lmsDMUCSrun' }
if 0 < verbose then
  lms.dmucsRunner = lms.dmucsRunner..' -V '..verbose
end
lms.dmucsRunner = lms.dmucsRunner..lms.dmucsServer

local dmucsRunnerCheckCMD = '( '..lms.dmucsRunner..' --check 2>&1 ) > /dev/null'
local dmucsRunnerCheck = os.execute(dmucsRunnerCheckCMD)
local foundDMUCSserver =
  (dmucsRunnerCheck == 0) or (dmucsRunnerCheck == true)
if useLUV and not foundDMUCSserver then
  lmsMessage{
    'Sorry... external commands can only be run in parallel',
    '         IF the DMUCS server is running'
  }
  useLUV = false
end

-- Now compute the OS (which can be used to require different versions of 
-- the lms modules) 

function getOutputFromCmd(aCmd)
  lmsMessageVery('getting output from: ['..aCmd..']')
  local proc = io.popen(aCmd..' 2>&1', 'r')
  if not proc then return '' end
  local result = proc:read('*a')
  proc:close()
  local result = result:gsub('\n$','')
  return result
end

if package.config:sub(1,1) == '\\' then
  lms.os = 'Windows'
else
  lms.os = getOutputFromCmd('uname -s')
end

-- Now create a collection of global functions to act as a DSL 

targets    = {}
targetList = {}

function runCmdIn(aTarget, cmd, subDir, onExit)
  subDirPath = subDir
  if cmd:find('^lms') then
    cmd = makePath { cmd, subDir }
  end
  subDirPath = makePath { dirPrefix, subDir }
  local curDir = lfs.currentdir()
  print('\n========================================================')
  print('working in ['..subDirPath..']')
  print('running    ['..cmd..']')
  lfs.chdir(subDir)
  executeCmd(aTarget, cmd, function(code, signal)
    lfs.chdir(curDir)
    if code ~= 0 then
      lmsError('FAILED to run: ['..cmd..']')
    end
    lmsMessageVery('running onExit')
    onExit(code, signal)
  end)
end

function runLocalCmdIn(aTarget, cmd, subDir, onExit)
  subDirPath = subDir
  if cmd:find('^lms') then
    cmd = makePath { cmd, subDir }
  end
  subDirPath = makePath { dirPrefix, subDir }
  local curDir = lfs.currentdir()
  print('\n========================================================')
  print('working in ['..subDirPath..']')
  print('running    ['..cmd..']')
  lfs.chdir(subDir)
  executeLocalCmd(aTarget, cmd, function(code, signal)
    lfs.chdir(curDir)
    if code ~= 0 then
      lmsError('FAILED to run: ['..cmd..']')
    end
    lmsMessageVery('running onExit')
    onExit(code, signal)
  end)
end

function executeCmd(aTarget, aCmd, onExit)
  if useLUV then
    lmsMessage('running: ['..aCmd..'] using luv.spawn')
    local cmdLogFile = logPrefix..'/'..aTarget:gsub('%/','_')
    lfs.mkdir(getParentPath(cmdLogFile))
    lmsMessageVery('logFile: ['..cmdLogFile..']')
    local wrappedCmd = lms.dmucsRunner..
      ' -l '..cmdLogFile..
      ' -d '..lfs.currentdir()..
      ' -c '..aCmd
    lmsMessageVery('using: ['..wrappedCmd..']')
    local spawnArguments = { }
    for anArg in wrappedCmd:gmatch("[^%s]+") do
      tInsert(spawnArguments, anArg)
    end
    lmsMessageVery('spawnComandArguments: '..prettyPrint(spawnArguments))
    local handle, pid = luv.spawn(
      spawnArguments[1],
      { args = spawnArguments },
      function(code, signal)
        if (0 < verbose) then
          lmsMessage('output from ['..aTarget..']')
          lmsMessageCont{
            'can be found in:',
            'less -r '..cmdLogFile
          }
        end
        if code == 0 then
          targets[aTarget].targetChanged = true
        else
          print('FAILED to run ['..aTarget..']')
          targets[aTarget].targetFailed = true
          targets[aTarget].logFile      = cmdLogFile
        end
        luv.async_send(asyncCheckTargets)
        onExit(code, signal)
      end
    )
  else
    lmsMessage('running: ['..aCmd..'] using os.execute')
    local result, resultType, code = os.execute(aCmd)
    -- texlua does not follow the official return valuse...
    -- so we map the texlua result into the lua return values
    if type(result) == 'number' then
      resultType = 'exit'
      if result == 0 then
        code = 0
        result = true
      else
        code = result
        result = false        
      end
    end
    if result then
      lmsMessageVery('onExit result true')
      targets[aTarget].targetChanged = true
      onExit(0, 0)
    elseif resultType == 'exit' then
      lmsMessageVery('onExit result false (code: '..toStr(code)..')')
      if code ~= 0 then
        lmsError('FAILED to run ['..aCmd..']')
      end
      onExit(code, 0)
    else
      lmsMessageVery('onExit result false (signal: '..toStr(code)..')')
      onExit(0, code)
    end
  end
end

function executeLocalCmd(aTarget, aCmd, onExit)
  lmsMessage('running: ['..aCmd..'] using os.execute (local)')
  local result, resultType, code = os.execute(aCmd)
    -- texlua does not follow the official return valuse...
    -- so we map the texlua result into the lua return values
    if type(result) == 'number' then
      resultType = 'exit'
      if result == 0 then
        code = 0
        result = true
      else
        code = result
        result = false        
      end
    end
  if result then
    lmsMessageVery('onExit result true')
    targets[aTarget].targetChanged = true
    onExit(0, 0)
  elseif resultType == 'exit' then
    lmsMessageVery('onExit result false (code: '..toStr(code)..')')
    onExit(code, 0)
  else
    lmsMessageVery('onExit result false (signal: '..toStr(code)..')')
    onExit(0, code)
  end
end

function chDir(aNewDir)
  if not lfs.chdir(aNewDir) then 
    lmsMessageCont('current directory: ['..lfs.currentdir()..']')
    lmsError('could not change directory to: ['..aNewDir..']')
  end
end

function collectSubDirectories(ignoredDirs)
  subDirs = { }
  for entry in lfs.dir('.') do
    if not entry:match('^%..*$') and
      (lfs.attributes(entry, 'mode') == 'directory') and
      not ignoredDirs:match(entry) then
      tInsert(subDirs, entry)
    end
  end
  tSort(subDirs)
  return subDirs
end

function addDependency(aTarget, aDependency)
  if not targets[aTarget] then
    targets[aTarget] = {
      dependencies = { },
      target       = aTarget
    }
    tInsert(targetList, aTarget)
  end
  if not aHasValue(targets[aTarget]['dependencies'], aDependency) then
    tInsert(targets[aTarget]['dependencies'], aDependency)
  end
end

function target(tDef)
  if 0 < #tDef then tDef.target       = tRemove(tDef, 1) end
  if 0 < #tDef then tDef.dependencies = tRemove(tDef, 1) end
  if 0 < #tDef then tDef.command      = tRemove(tDef, 1) end
  if 0 < #tDef then tDef.commandName  = tRemove(tDef, 1) end
  if not tDef.target or tDef.target:match('^%s*$') then 
    lmsError(debug.traceback('target method did not supply a target')) 
  end
  if targets[tDef.target] then -- first definition wins!
    print('Sorry the target: ['..tDef.target..'] already exists -- ignored!')
    showTarget(tDef.target)
    print("The NEW target is:")
    print(prettyPrint(tDef))
    print("=======================================")
  else
    tDef.targetRunning   = false
    tDef.targetCompleted = false
    tDef.targetChanged   = false
    targets[tDef.target] = tDef
    tInsert(targetList, tDef.target)
  end
  tDef.recurse = tDef.recurse or true
  return tDef.target
end

function getTargetFor(aTarget)
  return targets[aTarget]
end

function createNewTarget(targetName, targetVarName, targetCommand, targetCommandName)
  if not targetCommandName then
    targetCommandName = 'LMS::createNewTarget::targetCommand'
  end
  _G[targetVarName] = _G[targetVarName] or { }
  target{
    target       = targetName,
    dependencies = _G[targetVarName],
    noOutput     = true,
    mustBuild    = true,
    command      = targetCommand,
    commandName  = targetCommandName,
    creator      = 'createNewTarget'
  }
end

sha2 = require 'lms.sha2'

function computeSha256(aFilePath)
  local fileIO    = io.open(aFilePath, 'rb')
  if not fileIO then
    return nil
  end
  local appendSha = sha2.sha256()
  repeat
    local someBytes = fileIO:read(2^12)
    appendSha(someBytes)
  until not someBytes
  return appendSha()
end

function dependencyOutOfDate(tTime, aTarget, aTargetDef, aDependency, depTargetDef)
  lmsMessageVery("  checking dependency: ["..aDependency.."]")

  if depTargetDef and depTargetDef.noOutput then
    return false
  end

  if aTargetDef and aTargetDef.noOutput then
    return false
  end
  
  if (lfs.attributes(aDependency, 'mode') == 'directory') then
    return false
  end

  dTime = lfs.attributes(aDependency, 'modification')
  if not dTime then lmsError('missing dependency: ['..aDependency..']') end
  if dTime > tTime then
    lmsMessageCont{
      '  need to build ['..aTarget..']',
      '  since ['..aDependency..']',
      '  is newer ('..os.date('%Y/%m/%d %H:%M:%S', dTime)..')['..dTime..']',
      '  than the target ('..os.date('%Y/%m/%d %H:%M:%S', tTime)..')['..tTime..']'
      }
    return true
  end
  
  return false
end

function needsToBuild(aTargetDef)
  local aTarget = aTargetDef.target

  if type(aTargetDef.mustBuild) ~= 'nil' then
    lmsMessageCont('  must build '..aTarget)
    return true
  end

  if aTargetDef.targetChanged then
    lmsMessageCont('  must build due to artefact changed: '..aTarget)
    return true
  end

  local tTime = lfs.attributes(aTarget, 'modification')
  if type(aTargetDef.noOutput) == 'nil' then
    -- we should expect some file output...
    if not tTime then 
      lmsMessageCont{
        '  need to build ['..aTargetDef.target..']',
        '  since target does not exist'
      }
      return true
    end
  end

  lmsMessageVery(
    '  recursively checking need to build ['..aTarget..']'
  )
  for i, aDependency in ipairs(aTargetDef.dependencies) do
    -- recursively check the dependencies of this dependency
    -- (do a deep dive first)
    local depTargetDef = targets[aDependency]
    if depTargetDef then
      if needsToBuild(depTargetDef) then
        return true
      end
    else
      if dependencyOutOfDate(tTime, aTarget, aTargetDef, aDependency, depTargetDef) then
        return true
      end
    end
  end

  -- now check the sha256s
  lms.newFileInfo[aTarget] =
    lms.newFileInfo[aTarget] or computeSha256(aTarget)
  local newFileSha256 = lms.newFileInfo[aTarget]
  local oldFileSha256 = lms.oldFileInfo[aTarget] or ""
  if newFileSha256 == oldFileSha256 then
    lmsMessageVery(
      '  (the '..aTarget..' sha256s match so there is no need to rebuild)'
    )
    return false
  end
  
  -- now check the modification times of the dependencies
  for i, aDependency in ipairs(aTargetDef.dependencies) do
    if dependencyOutOfDate(tTime, aTarget, aTargetDef, aDependency, depTargetDef) then
      return true
    end
  end
  
  lmsMessageVery(
    '  all dependencies older than the ['..aTargetDef.target..'] target'
  )
  return false
end

function saveFileInfo()
  local fileInfo = hMerge(lms.oldFileInfo, lms.newFileInfo)
  fileInfoFile = io.open('lmsfileInfo', 'w')
  fileInfoFile:write('-- This is a automatically generated lua module\n')
  fileInfoFile:write('-- it is NOT wise to make any changes\n\n')
  fileInfoFile:write('local M = {}\n')
  for key, value in pairs(fileInfo) do
    fileInfoFile:write('  M["'..key..'"] = "'..value..'"\n')
  end
  fileInfoFile:write('return M\n')
  fileInfoFile:close()
end

function showTarget(targetToRun)
  print("=======================================")
  print("The target for: ["..targetToRun.."]")
  print(prettyPrint(targets[targetToRun]))
  print("=======================================")
end

function mustHaveTarget(targetToRun)
  local aTarget = targets[targetToRun]
  if not aTarget then
    lmsError(' no target found for ['..targetToRun..']')
  end
end

function runTarget(targetToRun)  
  lmsMessage('checking: '..targetToRun)
  
  local aTarget = targets[targetToRun]
  if not aTarget then
    lmsMessageCont('  ['..targetToRun..'] does not exist... nothing to do')
    return
  end
 
  if aTarget.targetFailed then
    lmsMessageCont('  FAILED target: '..targetToRun)
    return
  end
  
  if aTarget.targetCompleted then 
    lmsMessageCont('  already run '..targetToRun)
    return
  end
  
  if aTarget.targetRunning and not aTarget.targetCompleted then 
    lmsMessageCont('  already running '..targetToRun)
    return
  end

  if not aTarget.targetRunning then
    if not needsToBuild(aTarget) then
      lmsMessageCont('  no need to rebuild ['..targetToRun..']')
      aTarget.targetCompleted = true
      return
    end
  end

  local dependenciesCompleted = true
  if aTarget.dependencies then
    for i, aDependency in ipairs(aTarget.dependencies) do
      local depTargetDef = targets[aDependency]
      if depTargetDef then
        if depTargetDef.targetFailed then
          aTarget.targetFailed    = true
          aTarget.targetCompleted = true
          lmsMessageCont('  FAILED dependency: ['..aDependency..'] of ['..targetToRun..']')
          return
        end
        if not targets[aDependency].targetCompleted then
          runTarget(aDependency)
          if depTargetDef.targetFailed then
            aTarget.targetFailed    = true
            aTarget.targetCompleted = true
            lmsMessageCont('  FAILED dependency: ['..aDependency..'] of ['..targetToRun..']')
            return
          end
        end
        -- IF we are running in sequential mode this is useful
        if not targets[aDependency].targetCompleted then
          dependenciesCompleted = false
        end
      end
    end
  else
    lmsMessageCont('no dependencies key found')
  end
  
  if not dependenciesCompleted then
    lmsMessageVery('waiting for dependencies of '..targetToRun)
    return
  end

  aTarget.targetRunning = true
  
  lmsMessage('checking for '..targetToRun..' command:')
  if aTarget.command then
    lmsMessageCont('  has command ('..toStr(aTarget.command)..')')
    lmsMessageCont('              ('..aTarget.commandName..')')
    if type(aTarget.command) == 'string' then
      lmsMessage(
       'starting to build ['..aTarget.target..']\nusing ['..aTarget.command..']'
      )
      executeCmd(aTarget.target, aTarget.command, function(code, signal)
        lmsMessage(
         'finished building ['..aTarget.target..']\nusing ['..aTarget.command..']'
        )
        aTarget.targetCompleted = true
      end)
    elseif type(aTarget.command) == 'function' then
      lmsMessage('starting to build ['..aTarget.target..']')
      aTarget.command(aTarget, function(code, signal)
       if code == 0 then
          aTarget.targetChanged = true
        end
        lmsMessage('finished building ['..aTarget.target..']')
        aTarget.targetCompleted = true
      end)
    else
      lmsError(
        'the command for target ['..
        aTarget.target..
        '] MUST be either a string or a function.'
      )
    end
  else -- no command to run...
    lmsMessageCont('  has NO command')
    aTarget.targetCompleted = true
  end
end

-- Now we create some general helper tools

function getParentPath(aPath)
  local parentPath =
    aPath:gsub(directorySeparator..'?[^'..directorySeparator..']*$', '')
  if #parentPath < 1 then parentPath = nil end
  return parentPath
end

local function createPath(aTarget, onExit)
  lfs.mkdir(aTarget.target)
  lmsMessageVery('running onExit')
  onExit(0,0)
end

function ensurePathExists(aPath)
  if not aPath then return '' end
  local paths = { }
  local parentPath = getParentPath(aPath)
  if parentPath then
    ensurePathExists(parentPath)
    paths = { parentPath }
  end
  pathTarget = getTargetFor(aPath)
  if not pathTarget then
    pathTarget = target({
      dependencies = paths,
      target       = aPath,
      command      = createPath,
      commandName  = 'LMS::createPath',
      creator      = 'ensurePathExists'
    })
  end
  return pathTarget
end

function tCopy(origTable)
  if type(origTable) ~= 'table' then return origTable end
  
  local newTable = {}
  for i, aValue in ipairs(origTable) do
    tInsert(newTable, aValue)
  end
  for aKey, aValue in pairs(origTable) do
    newTable[aKey] = aValue
  end
  return newTable
end

-- merge a sequence of hash tables in order...
function hMerge(...)
  local newHash = { }
  for i, aHash in ipairs{...} do
    if type(aHash) == 'table' then
      for aKey, aValue in pairs(aHash) do
        if type(aValue) == 'table' then
          newHash[aKey] = tCopy(aValue)
        else
          newHash[aKey] = aValue
        end
      end
    end
  end
  return newHash
end

-- merge a sequence of arrays in order...
function aAppend(...)
  local newArray = { }
  for i, anArray in ipairs{...} do
    if type(anArray) == 'table' then
      for j, aValue in ipairs(anArray) do
        if type(aValue) == 'table' then
          tInsert(newArray, tCopy(aValue))
        else
          tInsert(newArray, aValue)
        end
      end
    end
  end
  return newArray
end

function aHasValue(anArray, aValue)
    for index, value in ipairs(anArray) do
        if value == aValue then
            return true
        end
    end
    return false
end

function aInsertOnce(anArray, aValue)
  if not aHasValue(anArray, aValue) then
    tInsert(anArray, aValue)
  end
end

-- find documents

function findDocuments(aDef)
  if type(aDef['docFiles']) ~= 'nil' then return end

  aDef['findRegexp'] = aDef['findRegexp'] or ".*\\.tex\\|.*Bib\\.lua"
  aDef['subDirs']    = aDef['subDirs']    or aDef['docDir']

  local docFiles = { }
  for i, aDir in ipairs(aDef['subDirs']) do
    local findCmd  = 'find '..aDir..' -iregex "'..aDef['findRegexp']..'"'
    lmsMessageVery('Dynamically finding documents using ['..findCmd..']')
    local texFileList = io.popen(findCmd)
    for docTexFilePath in texFileList:lines('*l') do
      docTexFilePath = './'..docTexFilePath
      table.insert(docFiles, docTexFilePath)
    end
  end
  aDef.docFiles = docFiles
end

-- Deal with sub-directory recursion

function doNotRecurseTarget(aTarget)
  if type(targets[aTarget]) ~= 'nil' then
    targets[aTarget].recurse = false
  end
end

function findSubDirs(aDef)
  if type(aDef['subDirs']) ~= 'nil' then
    if type(aDef['subDirs']) ~= 'table' then
      aDef['subDirs'] = { aDef['subDirs'] }
    end
    return
  end

  aDef['ignoreDirs'] = aDef['ignoreDirs'] or { 'releases', 'buildDir', 'bin' }

  local subDirs = { }
  local ignoreDirs = { }
  for i, aDir in ipairs(aDef['ignoreDirs']) do
    ignoreDirs[aDir] = true
  end
  for entry in lfs.dir('.') do
    if not entry:match('^%..*$') and
       (lfs.attributes(entry, 'mode') == 'directory') and
       not ignoreDirs[entry] then
      table.insert(subDirs, entry)
    end
  end
  aDef['subDirs'] = subDirs
end

function recurseCurrentTarget(aDef, onExit)
  if type(aDef['subDir']) ~= 'string' then
    print('  No subdir to recurse into...')
    return
  end

  if type(aDef['recurseCmd']) ~= 'string' then
    print('  No recurse command to run...')
    return
  end

  runCmdIn(aDef.target, aDef['recurseCmd'], aDef['subDir'], onExit)
end

function recurseTargets(aDef)
  if not recurse then return end

  local recurseDefaults = {
    ignoreDirs = { 'release', 'buildDir', 'bin', 'doc' }
  }
  aDef = hMerge(recurseDefaults, aDef)
  findSubDirs(aDef)

  local switches = ' '
  if (0 < verbose) then switches = switches .. '-v='..verbose..' ' end

  recurseTargets = { }
  for i, aTarget in ipairs(targetsToRun) do
    if targets[aTarget].recurse then
      for i, aSubDir in ipairs(aDef['subDirs']) do
        anRTargetName = aTarget..'-recurse-'..aSubDir
        anRTargetDef  = targets[anRTargetName] or { }

        anRTargetDef.target = anRTargetName
        anRTargetDef.dependencies =
          anRTargetDef.dependencies or { }

        anRTargetDef.command      = recurseCurrentTarget
        anRTargetDef.commandName  = 'LMS::recurseCurrentTarget'
        anRTargetDef.subDir       = aSubDir
        recurseCmd                =
          'lms -c -l='..logPrefix..'/'..anRTargetName ..
          switches .. aTarget .. ' -d=' .. dirPrefix
        anRTargetDef.recurseCmd   = recurseCmd
        anRTargetDef.mustBuild    = true

        targets[anRTargetName]    = anRTargetDef

        tInsert(recurseTargets, anRTargetName)
      end
    end
  end

  for i, aTarget in ipairs(recurseTargets) do
    tInsert(targetsToRun, aTarget)
  end  
end

-- Create the standard targets

createNewTarget('mainTarget', 'targetsToRun')

if #targetsToRun < 1 then
  tInsert(targetsToRun, 'default')
end

function nameCleanTarget(theTarget)
  return 'clean-'..theTarget
end

function cleanAllTargets(cDef, onExit)
  if cDef.dependencies then
    for i, aDep in ipairs(cDef.dependencies) do
        local aCmd = 'rm -rf '..aDep:gsub('^clean%-', '')
      lmsMessageCont(aCmd)
      os.execute(aCmd)
    end
  end
  lmsMessageVery('running onExit')
  onExit(0,0)
end

createNewTarget('clean', 'cleanTargets', cleanAllTargets, 'LMS::cleanAllTargets')

function nameClobberTarget(theTarget)
  return 'clobber-'..theTarget
end

function clobberAllTargets(cDef, onExit)
  runTarget('clean')
  lmsMessage('clobbering...')
  if cDef.dependencies then
    for i, aDep in ipairs(cDef.dependencies) do
      local aCmd = 'rm -rf '..aDep:gsub('^clobber%-', '')
      lmsMessageCont(aCmd)
      os.execute(aCmd)
      if aDep:find('lmsfileInfo') then
        lms.oldFileInfo = {}
      end
    end
  end
  
  lmsMessageVery('running onExit')
  onExit(0,0)
end

createNewTarget('clobber', 'clobberTargets', clobberAllTargets, 'LMS::clobberAllTargets')

tInsert(clobberTargets, nameClobberTarget('buildDir'))
tInsert(clobberTargets, nameClobberTarget('installDir'))
tInsert(clobberTargets, nameClobberTarget('lmsfileInfo'))

createNewTarget('doc',     'docTargets')
createNewTarget('bib',     'bibTargets')
createNewTarget('code',    'codeTargets')
createNewTarget('headers', 'headerTargets')
createNewTarget('build',   'buildTargets')
createNewTarget('install', 'installTargets')
createNewTarget('diff',    'diffTargets')
createNewTarget('tests',   'testTargets')
createNewTarget('default', 'buildTargets')

function listTargets()
  lmsMessage{} -- add a message bar if we are verbose
  tSort(targetList)
  for i, aTarget in ipairs(targetList) do
    aTDef = targets[aTarget]
    if aTDef then
      print(aTDef.target..':')
      if aTDef.command then
        print('      command: ['..prettyPrint(aTDef.command)..']')
        print('  commandName: ['..prettyPrint(aTDef.commandName)..']')
      else
        print('  no command')
      end
      if aTDef.dependencies then
        tSort(aTDef.dependencies)
        for i, aDependency in ipairs(aTDef.dependencies) do
          print('  '..aDependency)
        end
      else
        print('  no dependencies')
      end
    end
  end
  os.exit(0)
end

function listTargetStatus()
  tSort(targetList)

  local hasRunningTargets = false
  local hasFailedTargets  = false
  
  print('  completed targets:')
  for i, aTarget in ipairs(targetList) do
    local aTDef = targets[aTarget]
    if aTDef.targetCompleted then
      print('    '..aTDef.target)
    end
    if aTDef.targetRunning and not aTDef.targetCompleted then
      hasRunningTargets = true
    end
    if aTDef.targetFailed then
      hasFailedTargets = true
    end
  end
  
  if hasFailedTargets then
    print('  FAILED targets:')
    for i, aTarget in ipairs(targetList) do
      local aTDef = targets[aTarget]
      if aTDef.targetFailed then
        print('    '..aTDef.target)
        if aTDef.logFile then
          print('      less -r '..aTDef.logFile)
        end
      end
    end
  end
  
  if hasRunningTargets then
    print('  running targets:')
    for i, aTarget in ipairs(targetList) do
      local aTDef = targets[aTarget]
      if aTDef.targetRunning and not aTDef.targetCompleted then
        print('    '..aTDef.target)
     end
    end
  end
end

-- load the user's LMS file

require 'lmsfile'

if shouldListTargets then listTargets() end

-- execute it!

-- The following conditional require is adapted from: shuva's answer to 
--  "How to check if a module exists in Lua?"
-- see: http://stackoverflow.com/a/22686090

local hasLmsFileInfo, lmsFileInfo = pcall(require, "lmsfileInfo")
if not hasLmsFileInfo then
  print(lmsFileInfo)
  lmsFileInfo = { }
end
lms.oldFileInfo = lmsFileInfo
lms.newFileInfo = { }

if clearScreen then os.execute('reset') end

local function runTargets()

  lmsMessage('STARTING runTargets cycle')
  runTarget('mainTarget')
  lmsMessage('FINISHED runTargets cycle')
  
  if useLUV then
    if (0 < verbose) then listTargetStatus() end
    
    local noRunningTargets = true
    for i, aTarget in ipairs(targetList) do
      local aTDef = targets[aTarget]
      if aTDef.targetRunning and not aTDef.targetCompleted then
        noRunningTargets = false
      end
    end
  
    if noRunningTargets and targets['mainTarget'].targetCompleted then
      luv.unref(asyncCheckTargets)
    end
  end
end

asyncCheckTargets = function() end
checkTargets      = function() runTargets() end

if useLUV then
  lmsMessage('Using luv/libuv/DMUCS to parallelize this build')
  
  asyncCheckTargets = luv.new_async(runTargets)
  
  checkTargets      = function()
    luv.async_send(asyncCheckTargets)
    luv.run()
  end
end

checkTargets()

saveFileInfo()
